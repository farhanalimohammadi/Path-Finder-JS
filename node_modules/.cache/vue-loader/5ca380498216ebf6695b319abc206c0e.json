{"remainingRequest":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/src/components/PathfindingVisualizer.vue?vue&type=style&index=0&id=6b2e93b4&prod&lang=scss","dependencies":[{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/src/components/PathfindingVisualizer.vue","mtime":1771355133583},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/css-loader/dist/cjs.js","mtime":1771499059733},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1771499060595},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/postcss-loader/src/index.js","mtime":1771499059938},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/sass-loader/dist/cjs.js","mtime":1771499059514},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/cache-loader/dist/cjs.js","mtime":1771499059513},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/index.js","mtime":1771499060190}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CkBpbXBvcnQgJ0Avc2Nzcy92YXJpYWJsZXMuc2Nzcyc7CgoucGF0aGZpbmRpbmctdmlzdWFsaXplciB7Cgl3aWR0aDogMTAwdnc7CgloZWlnaHQ6IDEwMHZoOwoJb3ZlcmZsb3c6IGhpZGRlbjsKCgkuaGVhZGVyIHsKCQlwb3NpdGlvbjogYWJzb2x1dGU7CgkJdG9wOiAwOwoJCWxlZnQ6IDA7CgkJd2lkdGg6IDEwMCU7CgkJZGlzcGxheTogZmxleDsKCQlmbGV4LXdyYXA6IHdyYXA7CgkJYWxpZ24taXRlbXM6IGNlbnRlcjsKCQl0cmFuc2l0aW9uOiBhbGwgNTAwbXMgZWFzZS1vdXQ7CgkJei1pbmRleDogMTsKCgkJJjo6YmVmb3JlIHsKCQkJY29udGVudDogJyc7CgkJCXBvc2l0aW9uOiBhYnNvbHV0ZTsKCQkJdG9wOiAtMTAwJTsKCQkJbGVmdDogMDsKCQkJaGVpZ2h0OiAxMDAlOwoJCQl3aWR0aDogMTAwJTsKCQkJYm94LXNoYWRvdzogMXB4IDEwcHggNTBweCByZ2JhKDAsIDAsIDAsIDEpOwoJCQl6LWluZGV4OiAtMTsKCQl9CgoJCXNlbGVjdCB7CgkJCWhlaWdodDogNDBweDsKCQkJYmFja2dyb3VuZDogd2hpdGU7CgkJCWNvbG9yOiByZ2IoMCwgMCwgMCk7CgkJCXBhZGRpbmc6IDEwcHg7CgkJCW1hcmdpbjogMnB4OwoJCQlib3JkZXItcmFkaXVzOiAzcHg7CgkJCWJvcmRlcjogbm9uZTsKCQkJd2lkdGg6IGZpdC1jb250ZW50OwoJCX0KCX0KCgkuYnRuIHsKCQltYXJnaW46IDJweDsKCQlmb250LXNpemU6IDAuN2VtOwoJCWZvbnQtd2VpZ2h0OiA2MDA7CgkJdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsKCQkubGcgewoJCQlkaXNwbGF5OiBibG9jazsKCQl9CgkJLnNtIHsKCQkJZGlzcGxheTogbm9uZTsKCQl9Cgl9CgkuYnRuLXNldHVwIHsKCQl0b3A6IDYwcHg7CgkJJi5zZXR1cCB7CgkJCWJhY2tncm91bmQ6ICRzdWNjZXNzLWxvdzsKCQkJJjpob3ZlciB7CgkJCQliYWNrZ3JvdW5kOiAkc3VjY2VzczsKCQkJfQoJCX0KCX0KCS5idG4tY29udHJvbHMgewoJCXRvcDogMTE1cHg7Cgl9CgkuYnRuLWNhbWVyYSB7CgkJdG9wOiAxNzBweDsKCX0KCS5idG4tZGV2aWNlLWNhbSB7CgkJdG9wOiAyMjVweDsKCQkmLmFjdGl2ZSB7CgkJCWJhY2tncm91bmQ6ICRzdWNjZXNzLWxvdzsKCQkJJjpob3ZlciB7CgkJCQliYWNrZ3JvdW5kOiAkc3VjY2VzczsKCQkJfQoJCX0KCX0KCS5mYWxsYmFjay1pY29uIHsKCQlkaXNwbGF5OiBub25lOwoJfQoKCS5tYXplLWRyb3Bkb3duIHsKCQlwb3NpdGlvbjogcmVsYXRpdmU7CgoJCS5kcm9wZG93biB7CgkJCXBvc2l0aW9uOiBhYnNvbHV0ZTsKCQkJdG9wOiAxMDAlOwoJCQlsZWZ0OiAwOwoJCQl3aWR0aDogMTAwJTsKCQkJbWluLXdpZHRoOiBmaXQtY29udGVudDsKCQkJei1pbmRleDogMjsKCgkJCS5kcm9wZG93bi1pdGVtIHsKCQkJCXBhZGRpbmc6IDEwcHg7CgkJCQlmb250LXNpemU6IDAuOGVtOwoJCQkJZm9udC13ZWlnaHQ6IDYwMDsKCQkJCWNvbG9yOiB3aGl0ZTsKCQkJCWJhY2tncm91bmQ6ICRzZWNvbmRhcnk7CgkJCQljdXJzb3I6IHBvaW50ZXI7CgkJCQkmOmhvdmVyIHsKCQkJCQlmaWx0ZXI6IGJyaWdodG5lc3MoMC45KTsKCQkJCX0KCQkJfQoJCX0KCX0KCglAbWVkaWEgKG1heC13aWR0aDogNzkycHgpIHsKCQkuYnRuIHsKCQkJLmxnIHsKCQkJCWRpc3BsYXk6IG5vbmU7CgkJCX0KCQkJLnNtIHsKCQkJCWRpc3BsYXk6IGJsb2NrOwoJCQkJZm9udC1zaXplOiAwLjdlbTsKCQkJfQoJCQkmLmhvdmVyIHsKCQkJCSY6aG92ZXIgewoJCQkJCXdpZHRoOiA1NXB4OwoJCQkJfQoJCQl9CgkJfQoJCS5idG4tY2FtZXJhIHsKCQkJdG9wOiAxMTVweDsKCQl9CgkJLmJ0bi1kZXZpY2UtY2FtIHsKCQkJdG9wOiAxNzBweDsKCQl9CgkJLmZhbGxiYWNrLWljb24gewoJCQlkaXNwbGF5OiBibG9jazsKCQl9CgkJLmJ0bi1jb250cm9scyB7CgkJCWRpc3BsYXk6IG5vbmU7CgkJfQoJCS5oZWFkZXIgewoJCQlzZWxlY3QgewoJCQkJcGFkZGluZzogMnB4OwoJCQkJZm9udC1zaXplOiAwLjdlbTsKCQkJfQoJCX0KCX0KCgkjdmlkZW8tY2FudmFzIHsKCQlwb3NpdGlvbjogYWJzb2x1dGU7CgkJYm90dG9tOiAxMHB4OwoJCWxlZnQ6IDA7CgkJd2lkdGg6IDgwcHg7CgkJaGVpZ2h0OiA4MHB4OwoJCXZpc2liaWxpdHk6IGhpZGRlbjsKCX0KCSN2aWRlbyB7CgkJcG9zaXRpb246IGFic29sdXRlOwoJCWJvdHRvbTogODBweDsKCQlsZWZ0OiA0cHg7CgkJd2lkdGg6IDgwcHg7CgkJaGVpZ2h0OiA4MHB4OwoJCXRyYW5zZm9ybTogcm90YXRlWSgxODBkZWcpOwogICAgLXdlYmtpdC10cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpOyAvKiBTYWZhcmkgYW5kIENocm9tZSAqLwogICAgLW1vei10cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpOyAvKiBGaXJlZm94ICovCgl9CgkjdGhyZXNob2xkIHsKCQlwb3NpdGlvbjogYWJzb2x1dGU7CgkJYm90dG9tOiA1NXB4OwoJCWxlZnQ6IDNweDsKCQl3aWR0aDogODBweDsKCX0KCgkuc2xpZGUtZW50ZXItYWN0aXZlLAoJLnNsaWRlLWxlYXZlLWFjdGl2ZSB7CgkJdHJhbnNpdGlvbjogYWxsIDUwMG1zIGVhc2UtaW4tb3V0OwoJfQoJLnNsaWRlLWxlYXZlLWFjdGl2ZSB7CgkJcG9zaXRpb246IGFic29sdXRlOwoJfQoJLnNsaWRlLWVudGVyLAoJLnNsaWRlLWxlYXZlLXRvIHsKCQlvcGFjaXR5OiAwOwoJCXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsKCX0KCS5zbGlkZS1tb3ZlIHsKCQl0cmFuc2l0aW9uOiBhbGwgNTAwbXMgZWFzZS1pbi1vdXQ7Cgl9Cn0K"},{"version":3,"sources":["PathfindingVisualizer.vue"],"names":[],"mappings":";AAmkBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PathfindingVisualizer.vue","sourceRoot":"src/components","sourcesContent":["<template>\n\t<div class=\"pathfinding-visualizer\" @click=\"clearFocus\">\n\t\t<VisualizerCanvas\n\t\t\tref=\"visualizer\"\n\t\t\t:nodeDimensions=\"nodeDimensions\"\n\t\t\t:rows=\"rows\"\n\t\t\t:cols=\"cols\"\n\t\t\t:grid=\"grid\"\n\t\t\t:start=\"start\"\n\t\t\t:finish=\"finish\"\n\t\t\t:visualizerState=\"visualizerState\"\n\t\t\t:colors=\"colors\"\n\t\t\t:controlType=\"controlType\"\n\t\t\t:worldSetup=\"worldSetup\"\n\t\t\t:selectedAlgorithm=\"selectedAlgorithm\"\n\t\t\t:streaming=\"streaming\"\n\t\t\t:thresholdValue=\"thresholdValue\"\n\t\t\t@clickEvent=\"onClick\"\n\t\t\t@groundInitialized=\"ground = $event\"\n\t\t\t@switchWorldSetup=\"worldSetup = !worldSetup\"\n\t\t\t@switchControlType=\"controlType = controlType == 'Orbit' ? 'PointerLock' : 'Orbit'\"\n\t\t\t@updateEnds=\"updateEnds\"\n\t\t/>\n\t\t<transition-group name=\"slide\" mode=\"out-in\" tag=\"div\" class=\"header py-1\">\n\t\t\t<select\n\t\t\t\tid=\"algorithms\"\n\t\t\t\tv-model=\"selectedAlgorithm\"\n\t\t\t\t:disabled=\"visualizerState == 'running'\"\n\t\t\t\tkey=\"algo-select\"\n\t\t\t\tv-if=\"!worldSetup\"\n\t\t\t>\n\t\t\t\t<option :value=\"algo\" v-for=\"algo in algorithms\" :key=\"algo.algorithm\">{{\n\t\t\t\t\talgo.displayName\n\t\t\t\t}}</option>\n\t\t\t</select>\n\t\t\t<Button\n\t\t\t\tclass=\"accent\"\n\t\t\t\t@click=\"visualizeAlgorithm()\"\n\t\t\t\t:disabled=\"visualizerState == 'running' || worldSetup\"\n\t\t\t\tkey=\"visualize\"\n\t\t\t\tv-if=\"!worldSetup\"\n\t\t\t>\n\t\t\t\t<img class=\"fallback-icon\" src=\"@/assets/icons/path.svg\" alt=\"\" />\n\t\t\t\t<span class=\"lg\">اجرای الگوریتم</span>\n\t\t\t</Button>\n\t\t\t<Button class=\"danger\" @click=\"clearPath\" key=\"clear-path\" :disabled=\"visualizerState == 'running'\">\n\t\t\t\t<img class=\"fallback-icon\" src=\"@/assets/icons/cross.svg\" alt=\"\" />\n\t\t\t\t<span class=\"lg\">حذف مسیر</span>\n\t\t\t\t<span class=\"sm\">مسیر</span>\n\t\t\t</Button>\n\t\t\t<Button class=\"danger\" @click=\"clearWalls\" key=\"clear-walls\" :disabled=\"visualizerState == 'running'\">\n\t\t\t\t<img class=\"fallback-icon\" src=\"@/assets/icons/cross.svg\" alt=\"\" />\n\t\t\t\t<span class=\"lg\">حذف دیوارها</span>\n\t\t\t\t<span class=\"sm\">دیوارها</span>\n\t\t\t</Button>\n\t\t\t<div class=\"maze-dropdown\" key=\"maze-select\">\n\t\t\t\t<Button class=\"info btn-maze\" @click=\"onMazeDropdownClick\">\n\t\t\t\t\t<img class=\"fallback-icon\" src=\"@/assets/icons/maze.svg\" alt=\"\" />\n\t\t\t\t\t<span class=\"lg\">الگوریتم‌های ماز</span>\n\t\t\t\t</Button>\n\t\t\t\t<div class=\"dropdown\" v-if=\"dropdownOpen\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"dropdown-item\"\n\t\t\t\t\t\tv-for=\"algo in mazeAlgorithms\"\n\t\t\t\t\t\t:key=\"algo\"\n\t\t\t\t\t\t@click=\"generateMaze(algo)\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{{ algo }}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<select\n\t\t\t\tid=\"algorithms\"\n\t\t\t\tv-model=\"selectedSpeed\"\n\t\t\t\t:disabled=\"visualizerState == 'running'\"\n\t\t\t\tkey=\"speed-select\"\n\t\t\t\tv-if=\"!worldSetup\"\n\t\t\t>\n\t\t\t\t<option :value=\"speed\" v-for=\"speed in speeds\" :key=\"speed.text\">{{ speed.text }}</option>\n\t\t\t</select>\n\t\t</transition-group>\n\t\t<Button\n\t\t\tclass=\"hover btn-setup warning\"\n\t\t\t:class=\"{ setup: worldSetup }\"\n\t\t\tkey=\"setup\"\n\t\t\tv-if=\"controlType != 'PointerLock'\"\n\t\t\t@click=\"worldSetup = !worldSetup\"\n\t\t>\n\t\t\t<img src=\"@/assets/icons/setup.svg\" alt=\"\" />\n\t\t\t<span class=\"lg\">{{ worldSetup ? \"اتمام تنظیمات\" : \"تنظیم محیط\" }}</span>\n\t\t</Button>\n\t\t<Button\n\t\t\tclass=\"hover btn-controls warning\"\n\t\t\tkey=\"switch-controls\"\n\t\t\tv-if=\"!worldSetup\"\n\t\t\t@click=\"switchControl\"\n\t\t>\n\t\t\t<img src=\"@/assets/icons/street-view.svg\" alt=\"\" v-if=\"controlType == 'Orbit'\" />\n\t\t\t<img src=\"@/assets/icons/perspective.svg\" alt=\"\" v-else />\n\t\t\t<span class=\"lg\">{{ controlType == \"Orbit\" ? \"نمای اول‌شخص\" : \"نمای پرسپکتیو\" }}</span>\n\t\t</Button>\n\t\t<Button\n\t\t\tclass=\"hover btn-camera warning\"\n\t\t\tkey=\"reset-camera\"\n\t\t\tv-if=\"controlType == 'Orbit'\"\n\t\t\t@click=\"$refs.visualizer.resetCamera()\"\n\t\t>\n\t\t\t<img src=\"@/assets/icons/reset-camera.svg\" alt=\"\" />\n\t\t\t<span class=\"lg\">بازنشانی دوربین</span>\n\t\t</Button>\n\t\t<Button\n\t\t\tclass=\"hover btn-device-cam warning\"\n\t\t\t:class=\"{ active: deviceCamInput }\"\n\t\t\tkey=\"device-camera\"\n\t\t\tv-if=\"worldSetup\"\n\t\t\t@click=\"deviceCamInput = !deviceCamInput\"\n\t\t>\n\t\t\t<img src=\"@/assets/icons/camera.svg\" alt=\"\" />\n\t\t\t<span class=\"lg\">{{ \"ورودی دوربین\" }}</span>\n\t\t</Button>\n\n\t\t<canvas id=\"video-canvas\"></canvas>\n\t\t<video id=\"video\" autoplay></video>\n\t\t<input id=\"threshold\" ref=\"threshold\" v-if=\"deviceCamInput\" type=\"range\" min=\"0\" max=\"255\" v-model=\"thresholdValue\">\n\n\t\t<Info ref=\"info\" :colors=\"colors\" @unlockSwarm=\"unlockSwarm\"></Info>\n\t</div>\n</template>\n\n<script>\nimport VisualizerCanvas from \"./VisualizerCanvas.vue\";\nimport Info from '@/components/UI/Info.vue';\nimport * as THREE from \"three\";\nimport TWEEN from \"@tweenjs/tween.js\";\n\nimport { getNodesInShortestPathOrder, tweenToColor } from \"./algorithms/helpers.js\";\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\nimport { randomMaze, recursiveDivisionMaze } from \"./algorithms/mazeAlgorithms.js\";\n\n\nexport default {\n\tcomponents: {\n\t\tVisualizerCanvas,\n\t\tInfo\n\t},\n\tdata: () => ({\n\t\tvisualizerState: \"clear\", // clear/running/finished\n\t\talgorithms: [\n\t\t\t{\n\t\t\t\talgorithm: \"dijkstra\",\n\t\t\t\theuristic: \"\",\n\t\t\t\tdisplayName: \"Dijkstra's Algorithm\",\n\t\t\t\ttype: \"weighted\",\n\t\t\t\tinfo: {\n\t\t\t\t\theading: \"Dijkstra's Algorithm\",\n\t\t\t\t\ttext: `Dijkstra یکی از پایه‌ای‌ترین و مهم‌ترین الگوریتم‌های مسیریابی است که یک درخت از کوتاه‌ترین مسیرها را از رأس شروع (مبدأ) تا تمام نقاط دیگر گراف ایجاد می‌کند.\n\t\t\t\t\t<br><br>\n\t\t\t\t\tاین الگوریتم از نوع <b>وزن‌دار (weighted)</b> است و <b>کوتاه‌ترین مسیر</b> را تضمین می‌کند!`\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\talgorithm: \"astar\",\n\t\t\t\theuristic: \"poweredManhattanDistance\",\n\t\t\t\tdisplayName: \"A* Search\",\n\t\t\t\ttype: \"weighted\",\n\t\t\t\tinfo: {\n\t\t\t\t\theading: \"A* Search Algorithm\",\n\t\t\t\t\ttext: `A* یکی از قدرتمندترین و محبوب‌ترین الگوریتم‌ها برای مسیریابی و پیمایش گراف است. این الگوریتم با اضافه‌کردن یک تابع تخمینی (heuristic) به جست‌وجوی معمولی در گراف، در هر قدم کمی جلوتر را بررسی می‌کند تا تصمیم‌های بهینه‌تری بگیرد.\n\t\t\t\t\t<br><br>\n\t\t\t\t\tاین الگوریتم از نوع <b>وزن‌دار (weighted)</b> است و <b>کوتاه‌ترین مسیر</b> را تضمین می‌کند!`\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\talgorithm: \"bfs\",\n\t\t\t\theuristic: \"\",\n\t\t\t\tdisplayName: \"Breadth-first Search\",\n\t\t\t\ttype: \"unweighted\",\n\t\t\t\tinfo: {\n\t\t\t\t\theading: \"Breadth-first Search\",\n\t\t\t\t\ttext: `Breadth-first Search الگوریتمی برای پیمایش یا جست‌وجوی درخت و گراف است. این الگوریتم از ریشه شروع می‌کند و ابتدا تمام گره‌های هم‌سطح (در یک عمق) را بررسی می‌کند، سپس به سراغ سطح بعدی می‌رود.\n\t\t\t\t\t<br><br>\n\t\t\t\t\tاین الگوریتم از نوع <b>بدون‌وزن (unweighted)</b> است و <b>کوتاه‌ترین مسیر</b> را تضمین می‌کند!`\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\talgorithm: \"dfs\",\n\t\t\t\theuristic: \"\",\n\t\t\t\tdisplayName: \"Depth-first Search\",\n\t\t\t\ttype: \"unweighted\",\n\t\t\t\tinfo: {\n\t\t\t\t\theading: \"Depth-first Search\",\n\t\t\t\t\ttext: `Depth-first Search الگوریتمی برای پیمایش یا جست‌وجوی درخت و گراف است. الگوریتم از ریشه شروع می‌کند و تا جایی که ممکن باشد در هر شاخه به عمق می‌رود، سپس به عقب برمی‌گردد و شاخه‌های دیگر را ادامه می‌دهد.\n\t\t\t\t\t<br><br>\n\t\t\t\t\tاین الگوریتم از نوع <b>بدون‌وزن (unweighted)</b> است و <b>کوتاه‌ترین مسیر را تضمین نمی‌کند</b>!`\n\t\t\t\t}\n\t\t\t},\n\t\t],\n\t\tswarm: {\n\t\t\talgorithm: \"CLA\",\n\t\t\theuristic: \"manhattanDistance\",\n\t\t\tdisplayName: \"Swarm Algorithm\",\n\t\t\ttype: \"weighted\",\n\t\t\tinfo: {\n\t\t\t\theading: \"Swarm Algorithm\",\n\t\t\t\ttext: `Swarm Algorithm (به‌احتمال زیاد توسعه‌یافته توسط Clément Mihailescu و Hussein Farah) در اصل ترکیبی از Dijkstra و A* است. به‌طور دقیق‌تر، در حالی که مانند A* به سمت گره هدف همگرا می‌شود، همچنان شبیه Dijkstra تعداد قابل‌توجهی از گره‌های همسایه اطراف گره شروع را نیز کاوش می‌کند.\n\t\t\t\t<br><br>\n\t\t\t\tاین الگوریتم از نوع <b>وزن‌دار (weighted)</b> است و <b>کوتاه‌ترین مسیر را تضمین نمی‌کند</b>!`\n\t\t\t}\n\t\t},\n\t\tselectedAlgorithm: null,\n\t\tspeeds: [\n\t\t\t{\n\t\t\t\ttext: \"سریع\",\n\t\t\t\tvalue: 15,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttext: \"متوسط\",\n\t\t\t\tvalue: 25,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttext: \"کند\",\n\t\t\t\tvalue: 45,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttext: \"خیلی کند\",\n\t\t\t\tvalue: 80,\n\t\t\t},\n\t\t],\n\t\tselectedSpeed: null,\n\t\tmazeAlgorithms: [\"Random Maze\", \"Recursive Division\"],\n\t\tdropdownOpen: false,\n\t\tnodeDimensions: {\n\t\t\theight: 8,\n\t\t\twidth: 8,\n\t\t},\n\t\trows: 30,\n\t\tcols: 30,\n\t\tgrid: [],\n\t\tground: null,\n\t\tcontrolType: \"Orbit\", // Orbit/PointerLock\n\t\tstart: {\n\t\t\trow: 3,\n\t\t\tcol: 5,\n\t\t},\n\t\tfinish: {\n\t\t\trow: 16,\n\t\t\tcol: 22,\n\t\t},\n\t\tworldSetup: false,\n\t\tdeviceCamInput: false,\n\t\tstreaming: false,\n\t\tthresholdValue: 100,\n\t\tcolors: {\n\t\t\tdefault: { r: 1, g: 1, b: 1 },\n\t\t\tstart: { r: 0, g: 1, b: 0 },\n\t\t\tfinish: { r: 1, g: 0, b: 0 },\n\t\t\twall: { r: 0.109, g: 0.109, b: 0.45 },\n\t\t\tvisited: { r: 0.329, g: 0.27, b: 0.968 },\n\t\t\tpath: { r: 1, g: 1, b: 0 },\n\t\t},\n\t\tinfoStatus: '',\n\t\tinfoObject: {\n\t\t\theading: \"\",\n\t\t\ttext: \"\"\n\t\t}\n\t}),\n\twatch: {\n\t\tselectedAlgorithm: function(newVal, oldVal) {\n\t\t\tif (newVal.type == \"unweighted\") {\n\t\t\t\tthis.clearWalls();\n\t\t\t}\n\t\t\tthis.dropdownOpen = false;\n\t\t\tthis.$refs.info.resetToLegends();\n\t\t},\n\t\tworldSetup: function(newVal, oldVal) {\n\t\t\tif(newVal) {\n\t\t\t\tthis.clearPath();\n\t\t\t} else {\n\t\t\t\tthis.deviceCamInput = false;\n\t\t\t}\n\t\t},\n\t\tdeviceCamInput: function(newVal, oldVal) {\n\t\t\tif(newVal) {\n\t\t\t\tfunction hasGetUserMedia() {\n\t\t\t\t\treturn !!(navigator.mediaDevices &&\n\t\t\t\t\t\tnavigator.mediaDevices.getUserMedia);\n\t\t\t\t}\n\n\t\t\t\tthis.clearWalls();\n\n\t\t\t\tconst videoCanvas = document.querySelector('#video-canvas');\n\t\t\t\tlet videoCtx = videoCanvas.getContext(\"2d\");\n\t\t\t\tconst video = document.querySelector('video');\n\t\t\t\tthis.thresholdValue = 100;\n\t\t\t\tconst scale = 17;\n\t\t\t\tconst width = 512;\n\t\t\t\tconst height = 512;\n\t\t\t\tif (hasGetUserMedia()) {\n\t\t\t\t\tvideoCanvas.width = width/scale;\n\t\t\t\t\tvideoCanvas.height = height/scale;\n\t\t\t\t\tconst constraints = {\n\t\t\t\t\t\tvideo: { width: { exact: width/scale }, height: { exact: height/scale } }\n\t\t\t\t\t};\n\n\t\t\t\t\tnavigator.mediaDevices.getUserMedia(constraints)\n\t\t\t\t\t\t.then((stream) => {\n\t\t\t\t\t\t\tvideo.srcObject = stream;\n\t\t\t\t\t\t\tthis.streaming = true;\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\talert('getUserMedia() توسط مرورگر شما پشتیبانی نمی‌شود.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst video = document.querySelector('video');\n\t\t\t\tconst stream = video.srcObject;\n\t\t\t\tconst tracks = stream.getTracks();\n\n\t\t\t\ttracks.forEach(function(track) {\n\t\t\t\t\ttrack.stop();\n\t\t\t\t});\n\n\t\t\t\tvideo.srcObject = null;\n\t\t\t\tthis.streaming = false;\n\t\t\t}\n\t\t}\n\t},\n\tcreated() {\n\t\tthis.selectedAlgorithm = this.algorithms[0];\n\t\tthis.start.gridId = this.start.row * this.cols + this.start.col;\n\t\tthis.finish.gridId = this.finish.row * this.cols + this.finish.col;\n\t\tthis.selectedSpeed = this.speeds[0];\n\t},\n\tmethods: {\n\t\tonClick(node) {\n\t\t\tlet vm = this;\n\t\t\tif (this.visualizerState == \"running\") return;\n\t\t\tif(this.selectedAlgorithm.type == \"unweighted\") {\n\t\t\t\tthis.$refs.info.error({\n\t\t\t\t\theading: \"اوه!\",\n\t\t\t\t\ttext: \"در الگوریتم‌های بدون‌وزن (unweighted) امکان اضافه کردن دیوار وجود ندارد.\"\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (node.status != \"wall\") {\n\t\t\t\tif (node.status == \"start\" || node.status == \"finish\") return;\n\t\t\t\tnode.status = \"wall\";\n\t\t\t} else {\n\t\t\t\tnode.status = \"default\";\n\t\t\t}\n\t\t},\n\n\t\tonMazeDropdownClick() {\n\t\t\tif(this.selectedAlgorithm.type != 'unweighted') {\n\t\t\t\tthis.dropdownOpen = !this.dropdownOpen;\n\t\t\t} else {\n\t\t\t\tthis.dropdownOpen = false;\n\t\t\t\tthis.$refs.info.error({\n\t\t\t\t\theading: \"اوه!\",\n\t\t\t\t\ttext: \"در الگوریتم‌های بدون‌وزن (unweighted) امکان اضافه کردن دیوار وجود ندارد.\"\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tupdateEnds(obj) {\n\t\t\tif (obj.start) {\n\t\t\t\tthis.start = obj.start;\n\t\t\t\tthis.start.gridId = obj.start.row * this.cols + obj.start.col;\n\t\t\t} else {\n\t\t\t\tthis.finish = obj.finish;\n\t\t\t\tthis.finish.gridId = obj.finish.row * this.cols + obj.finish.col;\n\t\t\t}\n\t\t},\n\n\t\tunlockSwarm() {\n\t\t\tconsole.log('Unlocked Swarm');\n\t\t\tthis.algorithms.push(this.swarm);\n\t\t},\n\n\t\tclearWalls() {\n\t\t\tfor (let i = 0; i < this.rows; i++) {\n\t\t\t\tfor (let j = 0; j < this.cols; j++) {\n\t\t\t\t\tlet status = \"default\";\n\t\t\t\t\tif (this.grid[i][j].status == \"wall\") {\n\t\t\t\t\t\tthis.$set(this.grid[i][j], \"status\", status);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tclearPath() {\n\t\t\tTWEEN.removeAll();\n\t\t\tfor (let i = 0; i < this.rows; i++) {\n\t\t\t\tfor (let j = 0; j < this.cols; j++) {\n\t\t\t\t\tlet status = \"default\";\n\t\t\t\t\tif (i == this.start.row && j == this.start.col) {\n\t\t\t\t\t\tstatus = \"start\";\n\t\t\t\t\t} else if (i == this.finish.row && j == this.finish.col) {\n\t\t\t\t\t\tstatus = \"finish\";\n\t\t\t\t\t}\n\t\t\t\t\tif (this.grid[i][j].status != \"wall\") {\n\t\t\t\t\t\tthis.$set(this.grid[i][j], \"status\", status);\n\t\t\t\t\t}\n\t\t\t\t\tthis.$set(this.grid[i][j], \"distance\", Infinity);\n\t\t\t\t\tthis.$set(this.grid[i][j], \"totalDistance\", Infinity);\n\t\t\t\t\tthis.$set(this.grid[i][j], \"heuristicDistance\", null);\n\t\t\t\t\tthis.$set(this.grid[i][j], \"direction\", null);\n\t\t\t\t\tthis.$set(this.grid[i][j], \"previousNode\", null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.visualizerState = \"clear\";\n\t\t},\n\n\t\tswitchControl() {\n\t\t\tif (this.controlType == \"Orbit\") {\n\t\t\t\tthis.controlType = \"PointerLock\";\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.$refs.info.alert({\n\t\t\t\t\t\theading: \"شروع نمای اول‌شخص\",\n\t\t\t\t\t\ttext: \"برای شروع حرکت ماوس در نمای اول‌شخص، روی هر نقطه از بوم (Canvas) کلیک کنید. برای خروج از این حالت، کلید Esc را فشار دهید.\"\n\t\t\t\t\t});\n\t\t\t\t}, 2000)\n\t\t\t} else {\n\t\t\t\tthis.controlType = \"Orbit\";\n\t\t\t\tthis.$refs.info.resetToLegends();\n\t\t\t}\n\t\t},\n\n\t\tmoveCamera() {\n\t\t\tthis.$refs.visualizer.controls.enabled = false;\n\t\t\tnew TWEEN.Tween(this.$refs.visualizer.camera.position)\n\t\t\t\t.to({ x: -100, y: 200, z: 100 }, 2000)\n\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t.onUpdate(() => {\n\t\t\t\t\tthis.$refs.visualizer.camera.lookAt(this.$refs.visualizer.scene.position);\n\t\t\t\t\t// this.$refs.visualizer.controls.update();\n\t\t\t\t})\n\t\t\t\t.onComplete(() => {\n\t\t\t\t\tthis.$refs.visualizer.controls.enabled = true;\n\t\t\t\t})\n\t\t\t\t.start();\n\t\t\t// new TWEEN.Tween(this.$refs.visualizer.camera.rotation)\n\t\t\t// \t.to({ x: -(Math.PI/3), y: -(Math.PI/8), z: 0 }, 2000)\n\t\t\t// \t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t// \t.start();\n\t\t},\n\n\t\tvisualizeAlgorithm() {\n\t\t\tlet timerDelay = this.selectedSpeed.value;\n\t\t\tthis.clearPath();\n\t\t\t// this.moveCamera();\n\t\t\tthis.$nextTick(() => {\n\t\t\t\tthis.visualizerState = \"running\";\n\t\t\t\tconst startNode = this.grid[this.start.row][this.start.col];\n\t\t\t\tconst finishNode = this.grid[this.finish.row][this.finish.col];\n\t\t\t\tlet nodesToAnimate = [];\n\t\t\t\tlet success;\n\t\t\t\tif (this.selectedAlgorithm.type == \"weighted\") {\n\t\t\t\t\tsuccess = weightedSearchAlgorithm(\n\t\t\t\t\t\tthis.grid,\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tfinishNode,\n\t\t\t\t\t\tnodesToAnimate,\n\t\t\t\t\t\tthis.selectedAlgorithm.algorithm,\n\t\t\t\t\t\tthis.selectedAlgorithm.heuristic,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.clearWalls();\n\t\t\t\t\tsuccess = unweightedSearchAlgorithm(\n\t\t\t\t\t\tthis.grid,\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tfinishNode,\n\t\t\t\t\t\tnodesToAnimate,\n\t\t\t\t\t\tthis.selectedAlgorithm.algorithm\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconsole.log(\"success:\", success);\n\t\t\t\tif (success == false) {\n\t\t\t\t\tthis.clearPath();\n\t\t\t\t\tthis.visualizerState = \"finished\";\n\t\t\t\t\tthis.$refs.info.error({\n\t\t\t\t\t\theading: \"مسیر پیدا نشد\",\n\t\t\t\t\t\ttext: \"وقتی یکی از نقاط شروع یا پایان غیرقابل‌دسترسی باشد، مسیری بین آن‌ها پیدا نخواهد شد.\"\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\t\t\t\tthis.$nextTick(() => {\n\t\t\t\t\tthis.animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, timerDelay);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tanimateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, timerDelay) {\n\t\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder, 5 * timerDelay);\n\t\t\t\t\t}, timerDelay * i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t(visitedNodesInOrder[i].row == this.start.row &&\n\t\t\t\t\t\tvisitedNodesInOrder[i].col == this.start.col) ||\n\t\t\t\t\t(visitedNodesInOrder[i].row == this.finish.row &&\n\t\t\t\t\t\tvisitedNodesInOrder[i].col == this.finish.col)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\t\tif (!node) return;\n\t\t\t\t\ttweenToColor(\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tthis.ground.geometry,\n\t\t\t\t\t\t[{ r: 1.0, g: 0.321, b: 0.784 }, this.colors.visited],\n\t\t\t\t\t\t300,\n\t\t\t\t\t\t{ position: false }\n\t\t\t\t\t);\n\t\t\t\t}, timerDelay * i);\n\t\t\t}\n\t\t},\n\n\t\tanimateShortestPath(nodesInShortestPathOrder, timerDelay) {\n\t\t\tlet vm = this;\n\t\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst node = nodesInShortestPathOrder[i];\n\t\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.path], undefined, {\n\t\t\t\t\t\tposition: false,\n\t\t\t\t\t});\n\t\t\t\t\tif (i == nodesInShortestPathOrder.length - 1) {\n\t\t\t\t\t\tvm.visualizerState = \"finished\";\n\t\t\t\t\t\tvm.$refs.info.alert(this.selectedAlgorithm.info);\n\t\t\t\t\t}\n\t\t\t\t}, timerDelay * i);\n\t\t\t}\n\t\t},\n\n\t\tgenerateMaze(algo) {\n\t\t\tthis.dropdownOpen = false;\n\t\t\tthis.clearWalls();\n\t\t\tthis.clearPath();\n\t\t\tlet nodesToAnimate = [];\n\t\t\tif (algo == \"Random Maze\") {\n\t\t\t\trandomMaze(this.grid, nodesToAnimate, \"wall\");\n\t\t\t} else {\n\t\t\t\trecursiveDivisionMaze(\n\t\t\t\t\tthis.grid,\n\t\t\t\t\t2,\n\t\t\t\t\tthis.grid.length - 3,\n\t\t\t\t\t2,\n\t\t\t\t\tthis.grid[0].length - 3,\n\t\t\t\t\t\"horizontal\",\n\t\t\t\t\tfalse,\n\t\t\t\t\tnodesToAnimate,\n\t\t\t\t\t\"wall\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.animateMaze(nodesToAnimate, \"wall\", 30);\n\t\t},\n\n\t\tanimateMaze(visitedNodesInOrder, type, timerDelay) {\n\t\t\tfor (let i = 0; i < visitedNodesInOrder.length; i++) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\t\tnode.status = type;\n\t\t\t\t}, timerDelay * i);\n\t\t\t}\n\t\t},\n\n\t\tclearFocus() {\n\t\t\tdocument.getElementsByClassName(\"header\")[0].click();\n\t\t},\n\t},\n};\n</script>\n\n<style lang=\"scss\">\n@import '@/scss/variables.scss';\n\n.pathfinding-visualizer {\n\twidth: 100vw;\n\theight: 100vh;\n\toverflow: hidden;\n\n\t.header {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\tdisplay: flex;\n\t\tflex-wrap: wrap;\n\t\talign-items: center;\n\t\ttransition: all 500ms ease-out;\n\t\tz-index: 1;\n\n\t\t&::before {\n\t\t\tcontent: '';\n\t\t\tposition: absolute;\n\t\t\ttop: -100%;\n\t\t\tleft: 0;\n\t\t\theight: 100%;\n\t\t\twidth: 100%;\n\t\t\tbox-shadow: 1px 10px 50px rgba(0, 0, 0, 1);\n\t\t\tz-index: -1;\n\t\t}\n\n\t\tselect {\n\t\t\theight: 40px;\n\t\t\tbackground: white;\n\t\t\tcolor: rgb(0, 0, 0);\n\t\t\tpadding: 10px;\n\t\t\tmargin: 2px;\n\t\t\tborder-radius: 3px;\n\t\t\tborder: none;\n\t\t\twidth: fit-content;\n\t\t}\n\t}\n\n\t.btn {\n\t\tmargin: 2px;\n\t\tfont-size: 0.7em;\n\t\tfont-weight: 600;\n\t\ttext-transform: uppercase;\n\t\t.lg {\n\t\t\tdisplay: block;\n\t\t}\n\t\t.sm {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\t.btn-setup {\n\t\ttop: 60px;\n\t\t&.setup {\n\t\t\tbackground: $success-low;\n\t\t\t&:hover {\n\t\t\t\tbackground: $success;\n\t\t\t}\n\t\t}\n\t}\n\t.btn-controls {\n\t\ttop: 115px;\n\t}\n\t.btn-camera {\n\t\ttop: 170px;\n\t}\n\t.btn-device-cam {\n\t\ttop: 225px;\n\t\t&.active {\n\t\t\tbackground: $success-low;\n\t\t\t&:hover {\n\t\t\t\tbackground: $success;\n\t\t\t}\n\t\t}\n\t}\n\t.fallback-icon {\n\t\tdisplay: none;\n\t}\n\n\t.maze-dropdown {\n\t\tposition: relative;\n\n\t\t.dropdown {\n\t\t\tposition: absolute;\n\t\t\ttop: 100%;\n\t\t\tleft: 0;\n\t\t\twidth: 100%;\n\t\t\tmin-width: fit-content;\n\t\t\tz-index: 2;\n\n\t\t\t.dropdown-item {\n\t\t\t\tpadding: 10px;\n\t\t\t\tfont-size: 0.8em;\n\t\t\t\tfont-weight: 600;\n\t\t\t\tcolor: white;\n\t\t\t\tbackground: $secondary;\n\t\t\t\tcursor: pointer;\n\t\t\t\t&:hover {\n\t\t\t\t\tfilter: brightness(0.9);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@media (max-width: 792px) {\n\t\t.btn {\n\t\t\t.lg {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t.sm {\n\t\t\t\tdisplay: block;\n\t\t\t\tfont-size: 0.7em;\n\t\t\t}\n\t\t\t&.hover {\n\t\t\t\t&:hover {\n\t\t\t\t\twidth: 55px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t.btn-camera {\n\t\t\ttop: 115px;\n\t\t}\n\t\t.btn-device-cam {\n\t\t\ttop: 170px;\n\t\t}\n\t\t.fallback-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t\t.btn-controls {\n\t\t\tdisplay: none;\n\t\t}\n\t\t.header {\n\t\t\tselect {\n\t\t\t\tpadding: 2px;\n\t\t\t\tfont-size: 0.7em;\n\t\t\t}\n\t\t}\n\t}\n\n\t#video-canvas {\n\t\tposition: absolute;\n\t\tbottom: 10px;\n\t\tleft: 0;\n\t\twidth: 80px;\n\t\theight: 80px;\n\t\tvisibility: hidden;\n\t}\n\t#video {\n\t\tposition: absolute;\n\t\tbottom: 80px;\n\t\tleft: 4px;\n\t\twidth: 80px;\n\t\theight: 80px;\n\t\ttransform: rotateY(180deg);\n    -webkit-transform:rotateY(180deg); /* Safari and Chrome */\n    -moz-transform:rotateY(180deg); /* Firefox */\n\t}\n\t#threshold {\n\t\tposition: absolute;\n\t\tbottom: 55px;\n\t\tleft: 3px;\n\t\twidth: 80px;\n\t}\n\n\t.slide-enter-active,\n\t.slide-leave-active {\n\t\ttransition: all 500ms ease-in-out;\n\t}\n\t.slide-leave-active {\n\t\tposition: absolute;\n\t}\n\t.slide-enter,\n\t.slide-leave-to {\n\t\topacity: 0;\n\t\ttransform: translateY(-50%);\n\t}\n\t.slide-move {\n\t\ttransition: all 500ms ease-in-out;\n\t}\n}\n</style>\n"]}]}