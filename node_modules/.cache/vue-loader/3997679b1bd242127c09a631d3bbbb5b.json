{"remainingRequest":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/src/components/VisualizerCanvas.vue?vue&type=style&index=0&id=51769354&prod&lang=scss","dependencies":[{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/src/components/VisualizerCanvas.vue","mtime":1771256159756},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/css-loader/dist/cjs.js","mtime":1771499059733},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1771499060595},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/postcss-loader/src/index.js","mtime":1771499059938},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/sass-loader/dist/cjs.js","mtime":1771499059514},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/cache-loader/dist/cjs.js","mtime":1771499059513},{"path":"/home/farhan/Desktop/My-Projects/city-project/Pathfinding-Visualizer-ThreeJS/node_modules/vue-loader/lib/index.js","mtime":1771499060190}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiN2aXN1YWxpemVyIHsKCWhlaWdodDogMTAwdmg7Cgl3aWR0aDogMTAwdnc7Cn0K"},{"version":3,"sources":["VisualizerCanvas.vue"],"names":[],"mappings":";AAo7BA;AACA;AACA;AACA","file":"VisualizerCanvas.vue","sourceRoot":"src/components","sourcesContent":["<template>\n\t<div id=\"visualizer\" @click=\"controlType == 'PointerLock' ? controls.lock() : clearFocus\">\n\t\t<script type=\"x-shader/x-vertex\" id=\"vertexShader\">\n\t\t\tvarying vec3 vWorldPosition;\n\n\t\t\tvoid main() {\n\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\tvWorldPosition = worldPosition.xyz;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t}\n\t\t</script>\n\t\t<script type=\"x-shader/x-fragment\" id=\"fragmentShader\">\n\t\t\tuniform vec3 topColor;\n\t\t\tuniform vec3 bottomColor;\n\t\t\tuniform float offset;\n\t\t\tuniform float exponent;\n\n\t\t\tvarying vec3 vWorldPosition;\n\n\t\t\tvoid main() {\n\t\t\t\tfloat h = normalize( vWorldPosition + offset ).y;\n\t\t\t\tgl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );\n\t\t\t}\n\t\t</script>\n\t</div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\nimport { PointerLockControls } from \"three/examples/jsm/controls/PointerLockControls.js\";\nimport TWEEN, { removeAll } from \"@tweenjs/tween.js\";\nimport Stats from \"three/examples/jsm/libs/stats.module.js\";\n\nimport { getAllNodes, tweenToColor } from \"./algorithms/helpers.js\";\n\nexport default {\n\tprops: [\n\t\t\"nodeDimensions\",\n\t\t\"grid\",\n\t\t\"rows\",\n\t\t\"cols\",\n\t\t\"start\",\n\t\t\"finish\",\n\t\t\"visualizerState\",\n\t\t\"colors\",\n\t\t\"controlType\",\n\t\t\"worldSetup\",\n\t\t\"selectedAlgorithm\",\n\t\t\"streaming\",\n\t\t\"thresholdValue\"\n\t],\n\tdata: () => ({\n\t\tscene: null,\n\t\tcamera: null,\n\t\tcameraY: 0,\n\t\tdefaultCameraY: 250,\n\t\trenderer: null,\n\t\tpointerLock: {\n\t\t\tmoveForward: false,\n\t\t\tmoveBackward: false,\n\t\t\tmoveLeft: false,\n\t\t\tmoveRight: false,\n\t\t\tvelocity: null,\n\t\t\tdirection: null,\n\t\t\tprevTime: null,\n\t\t},\n\t\tcontrols: null,\n\t\torbitControls: null,\n\t\tpointerLockControls: null,\n\t\traycaster: null,\n\t\tambientLight: null,\n\t\themisphereLight: null,\n\t\tdirectionalLight: null,\n\t\tground: null,\n\t\twallGeomtery: null,\n\t\twallMaterials: [],\n\t\twalls: {},\n\t\twallTextures: [\n\t\t\t{\n\t\t\t\tpath: \"building1.png\",\n\t\t\t\trepeatY: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: \"building2.png\",\n\t\t\t\trepeatY: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: \"building3.png\",\n\t\t\t\trepeatY: 3,\n\t\t\t},\n\t\t],\n\t\tdown: false,\n\t\tmoved: false,\n\t\tcurrentEvent: null,\n\t\tmouse: null,\n\t\tintersectedNode: null,\n\t\tclock: null,\n\t\tstats: null,\n\t\t// Device cam\n\t\tvideoCanvas: null,\n\t\tvideo: null\n\t}),\n\tcomputed: {\n\t\tclickableObjects() {\n\t\t\tlet objects = [];\n\t\t\tobjects.push(this.ground);\n\t\t\tfor (let id of Object.keys(this.walls)) {\n\t\t\t\tif (this.walls[id].visible) {\n\t\t\t\t\tobjects.push(this.walls[id]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn objects;\n\t\t},\n\t\tcollidableObjects() {\n\t\t\tlet objects = [];\n\t\t\tfor (let id of Object.keys(this.walls)) {\n\t\t\t\tif (this.walls[id].visible) {\n\t\t\t\t\tobjects.push(this.walls[id]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn objects;\n\t\t}\n\t},\n\twatch: {\n\t\tcontrolType: function(newVal, oldVal) {\n\t\t\tthis.setControls();\n\t\t},\n\t\tworldSetup: function(newVal, oldVal) {\n\t\t\tif (newVal) {\n\t\t\t\tTWEEN.removeAll();\n\t\t\t\tnew TWEEN.Tween(this.camera.position)\n\t\t\t\t\t.to({ x: 0, y: this.cameraY - 30, z: 0 }, 500)\n\t\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t\t.onUpdate(() => {\n\t\t\t\t\t\tthis.camera.lookAt(this.scene.position);\n\t\t\t\t\t})\n\t\t\t\t\t.onComplete(() => {\n\t\t\t\t\t\tthis.controls.enableRotate = false;\n\t\t\t\t\t\tlet lookDirection = new THREE.Vector3();\n\t\t\t\t\t\tthis.camera.getWorldDirection(lookDirection);\n\t\t\t\t\t\tthis.controls.target\n\t\t\t\t\t\t\t.copy(this.camera.position)\n\t\t\t\t\t\t\t.add(lookDirection.multiplyScalar(this.cameraY - 30));\n\t\t\t\t\t})\n\t\t\t\t\t.start();\n\t\t\t\tnew TWEEN.Tween(this.camera.rotation)\n\t\t\t\t\t.to({ y: 0, z: 0 }, 500)\n\t\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t\t.start();\n\t\t\t} else {\n\t\t\t\tnew TWEEN.Tween(this.camera.position)\n\t\t\t\t\t.to({ y: this.cameraY }, 500)\n\t\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t\t.onComplete(() => {\n\t\t\t\t\t\tthis.controls.enableRotate = true;\n\t\t\t\t\t\tthis.controls.update();\n\t\t\t\t\t})\n\t\t\t\t\t.start();\n\t\t\t}\n\t\t},\n\t\tstreaming: function(newVal, oldVal) {\n\t\t\tif(!newVal) {\n\t\t\t\tfor(let i=0; i<this.rows; i++) {\n\t\t\t\t\tfor(let j=0; j<this.cols; j++) {\n\t\t\t\t\t\tthis.updateNode(this.grid[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcreated() {\n\t\tthis.cameraY = this.defaultCameraY;\n\t},\n\tmounted() {\n\t\tthis.init();\n\t\t\n\t\tthis.videoCanvas = document.querySelector('#video-canvas');\n\t\tthis.video = document.querySelector('video');\n\t},\n\tmethods: {\n\t\tinit() {\n\t\t\tlet width = window.innerWidth,\n\t\t\t\theight = window.innerHeight;\n\n\t\t\t//Scene\n\t\t\tthis.scene = new THREE.Scene();\n\t\t\tthis.scene.background = new THREE.Color(0xbbd6ff);\n\t\t\tthis.scene.fog = new THREE.Fog(0xffffff, 0, 750);\n\n\t\t\t//Camera\n\t\t\tthis.camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);\n\t\t\tthis.camera.position.y = this.cameraY + 2000;\n\t\t\tthis.camera.position.x = -500;\n\t\t\tthis.camera.position.z = 500;\n\t\t\t// var helper = new THREE.CameraHelper(this.camera);\n\t\t\t// this.scene.add(helper);\n\n\t\t\t//Renderer\n\t\t\tthis.renderer = new THREE.WebGLRenderer({ antialias: true });\n\t\t\tthis.renderer.setSize(width, height);\n\t\t\tthis.renderer.shadowMap.enabled = true;\n\t\t\t// this.renderer.shadowMap.type = THREE.BasicShadowMap;\n\t\t\tdocument.getElementById(\"visualizer\").appendChild(this.renderer.domElement);\n\n\t\t\t// Controls\n\t\t\tthis.addControls();\n\t\t\tthis.setControls(true);\n\n\t\t\t// Raycaster\n\t\t\tthis.raycaster = new THREE.Raycaster();\n\n\t\t\t// Ground\n\t\t\tlet gridWidth = this.cols * this.nodeDimensions.width,\n\t\t\t\tgridHeight = this.rows * this.nodeDimensions.height;\n\t\t\tlet vm = this;\n\t\t\tlet groundGeometry = new THREE.PlaneGeometry(gridWidth, gridHeight, this.cols, this.rows);\n\t\t\tgroundGeometry.rotateX(-Math.PI / 2);\n\t\t\tlet loader = new THREE.TextureLoader();\n\t\t\tloader.load(\n\t\t\t\trequire(\"@/assets/textures/ground.png\"),\n\t\t\t\tfunction(texture) {\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.x = vm.rows;\n\t\t\t\t\ttexture.repeat.y = vm.cols;\n\t\t\t\t\tvar groundMaterial = new THREE.MeshLambertMaterial({\n\t\t\t\t\t\tmap: texture,\n\t\t\t\t\t\tside: THREE.FrontSide,\n\t\t\t\t\t\tvertexColors: THREE.FaceColors,\n\t\t\t\t\t});\n\t\t\t\t\tvm.ground = new THREE.Mesh(groundGeometry, groundMaterial);\n\t\t\t\t\tvm.ground.receiveShadow = true;\n\t\t\t\t\tvm.ground.position.y = 0.02;\n\t\t\t\t\tvm.scene.add(vm.ground);\n\t\t\t\t\tvm.initGrid();\n\t\t\t\t\tvm.$emit(\"groundInitialized\", vm.ground);\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\tfunction(error) {\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t}\n\t\t\t);\n\t\t\tlet fakeGroundGeometry = new THREE.PlaneGeometry(1000, 1000, this.cols, this.rows);\n\t\t\tfakeGroundGeometry.rotateX(-Math.PI / 2);\n\t\t\tvar fakeGroundMaterial = new THREE.MeshLambertMaterial({\n\t\t\t\t// color: 0x87775d,\n\t\t\t\tcolor: 0xBBC2D0,\n\t\t\t\tside: THREE.FrontSide,\n\t\t\t});\n\t\t\tlet fakeGround = new THREE.Mesh(fakeGroundGeometry, fakeGroundMaterial);\n\t\t\tthis.scene.add(fakeGround);\n\n\t\t\t//Grid helper\n\t\t\tvar size = this.cols * this.nodeDimensions.height;\n\t\t\tvar divisions = this.cols;\n\t\t\tvar gridHelper = new THREE.GridHelper(size, divisions, 0x5c78bd, 0x5c78bd);\n\t\t\tgridHelper.position.y = 0.035;\n\t\t\tthis.scene.add(gridHelper);\n\n\t\t\t// Wall\n\t\t\t// let wallHeight = this.nodeDimensions.width * 2 + Math.random() * this.nodeDimensions.width * 3;\n\t\t\tlet wallHeight = this.nodeDimensions.height * 2;\n\t\t\tthis.wallGeomtery = new THREE.BoxBufferGeometry(\n\t\t\t\tthis.nodeDimensions.width,\n\t\t\t\twallHeight,\n\t\t\t\tthis.nodeDimensions.height\n\t\t\t);\n\t\t\tlet wallTextureObject = this.wallTextures[\n\t\t\t\tMath.floor(Math.random() * this.wallTextures.length)\n\t\t\t];\n\t\t\tthis.wallMaterials.push(\n\t\t\t\tnew THREE.MeshPhongMaterial({\n\t\t\t\t\tcolor: new THREE.Color(this.colors.wall.r, this.colors.wall.g, this.colors.wall.b),\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor (let tex of this.wallTextures) {\n\t\t\t\tloader.load(\n\t\t\t\t\trequire(\"@/assets/textures/\" + tex.path),\n\t\t\t\t\tfunction(texture) {\n\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.repeat.y = tex.repeatY;\n\t\t\t\t\t\tvm.wallMaterials.push(new THREE.MeshLambertMaterial({ map: texture }));\n\t\t\t\t\t},\n\t\t\t\t\tundefined,\n\t\t\t\t\tfunction(error) {\n\t\t\t\t\t\tconsole.log(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Ambient Light\n\t\t\tthis.ambientLight = new THREE.AmbientLight(0xffffff, 1);\n\t\t\tthis.scene.add(this.ambientLight);\n\n\t\t\t// LIGHTS\n\t\t\tthis.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.1);\n\t\t\tthis.hemisphereLight.color.setHSL(0.6, 1, 0.6);\n\t\t\tthis.hemisphereLight.groundColor.setHex(0x87775d);\n\t\t\tthis.hemisphereLight.position.set(0, 5, 0);\n\t\t\tthis.scene.add(this.hemisphereLight);\n\n\t\t\t// let hemiLightHelper = new THREE.HemisphereLightHelper(this.hemisphereLight, 10);\n\t\t\t// this.scene.add(hemiLightHelper);\n\n\t\t\tthis.directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n\t\t\tthis.directionalLight.color.setHSL(0.1, 1, 0.95);\n\t\t\tthis.directionalLight.position.set(-1, 1.75, 1);\n\t\t\tthis.directionalLight.position.multiplyScalar(70);\n\t\t\tthis.scene.add(this.directionalLight);\n\n\t\t\tthis.directionalLight.castShadow = true;\n\t\t\tthis.directionalLight.shadow.mapSize.width = 2048;\n\t\t\tthis.directionalLight.shadow.mapSize.height = 2048;\n\n\t\t\tvar d = 200;\n\t\t\tthis.directionalLight.shadow.camera.left = -d;\n\t\t\tthis.directionalLight.shadow.camera.right = d;\n\t\t\tthis.directionalLight.shadow.camera.top = d;\n\t\t\tthis.directionalLight.shadow.camera.bottom = -d;\n\t\t\tthis.directionalLight.shadow.camera.far = 350;\n\n\t\t\t// SKYDOME\n\t\t\tvar vertexShader = document.getElementById(\"vertexShader\").textContent;\n\t\t\tvar fragmentShader = document.getElementById(\"fragmentShader\").textContent;\n\t\t\tvar uniforms = {\n\t\t\t\ttopColor: { value: new THREE.Color(0x0077ff) },\n\t\t\t\tbottomColor: { value: new THREE.Color(0xffffff) },\n\t\t\t\toffset: { value: 33 },\n\t\t\t\texponent: { value: 0.6 },\n\t\t\t};\n\t\t\tuniforms[\"topColor\"].value.copy(this.hemisphereLight.color);\n\n\t\t\tthis.scene.fog.color.copy(uniforms[\"bottomColor\"].value);\n\t\t\tvar skyGeo = new THREE.SphereBufferGeometry(1000, 32, 15);\n\t\t\tvar skyMat = new THREE.ShaderMaterial({\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: THREE.BackSide,\n\t\t\t});\n\t\t\tvar sky = new THREE.Mesh(skyGeo, skyMat);\n\t\t\tthis.scene.add(sky);\n\n\t\t\t// Stats\n\t\t\tthis.stats = new Stats();\n\t\t\tthis.stats.dom.style.top = \"auto\";\n\t\t\tthis.stats.dom.style.bottom = '5px';\n\t\t\tthis.stats.dom.style.left = '3px';\n\t\t\tdocument.getElementById(\"visualizer\").appendChild(this.stats.dom);\n\n\t\t\t//Resize handler\n\t\t\twindow.addEventListener(\"resize\", this.resizeHandler);\n\t\t\tthis.renderer.domElement.addEventListener(\"mousedown\", this.onMouseDown, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"touchstart\", this.onMouseDown, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"mousemove\", this.onMouseMove, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"touchmove\", this.onMouseMove, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"mouseup\", this.onMouseup, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"mouseleave\", this.onMouseLeave, true);\n\t\t\tthis.renderer.domElement.addEventListener(\"touchend\", this.onMouseup, true);\n\n\t\t\t// Setting hover handler\n\t\t\tthis.mouse = new THREE.Vector2();\n\n\t\t\tthis.renderLoop();\n\t\t},\n\n\t\trenderLoop() {\n\t\t\trequestAnimationFrame(this.renderLoop);\n\t\t\tif (this.controlType == \"PointerLock\") {\n\t\t\t\tvar delta = this.clock.getDelta();\n\t\t\t\tthis.animatePlayer(delta);\n\t\t\t}\n\t\t\tif (this.worldSetup) {\n\t\t\t\tthis.hoverObjectLoop();\n\t\t\t\tif(this.streaming) {\n\t\t\t\t\tthis.deviceCamLoop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.renderer.render(this.scene, this.camera);\n\t\t\tTWEEN.update();\n\t\t\tthis.stats.update();\n\t\t},\n\n\t\thoverObjectLoop() {\n\t\t\tif (!this.down) {\n\t\t\t\tthis.intersectedNode = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.raycaster.setFromCamera(this.mouse, this.camera);\n\t\t\tvar intersects = this.raycaster.intersectObjects(this.clickableObjects);\n\t\t\tif (intersects.length > 0) {\n\t\t\t\tlet coords;\n\t\t\t\tif (intersects[0].object.name == \"wall\") {\n\t\t\t\t\tcoords = this.faceIndexToCoordinates(intersects[0].object.wallId * 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar faceIndex = intersects[0].faceIndex;\n\t\t\t\t\tcoords = this.faceIndexToCoordinates(faceIndex);\n\t\t\t\t}\n\n\t\t\t\tif (this.grid[coords.row][coords.col] != this.intersectedNode) {\n\t\t\t\t\tlet ends = [\"start\", \"finish\"];\n\t\t\t\t\tif (\n\t\t\t\t\t\tends.includes(this.grid[coords.row][coords.col].status) ||\n\t\t\t\t\t\t(this.intersectedNode && ends.includes(this.intersectedNode.status))\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet end;\n\t\t\t\t\t\tif (ends.includes(this.grid[coords.row][coords.col].status)) {\n\t\t\t\t\t\t\tend = this.grid[coords.row][coords.col].status;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = this.intersectedNode.status;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet obj = {};\n\t\t\t\t\t\tobj[end] = {\n\t\t\t\t\t\t\trow: coords.row,\n\t\t\t\t\t\t\tcol: coords.col,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (this.intersectedNode && ends.includes(this.intersectedNode.status)) {\n\t\t\t\t\t\t\tthis.intersectedNode.status = \"default\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.grid[coords.row][coords.col].status = end;\n\t\t\t\t\t\tthis.$emit(\"updateEnds\", obj);\n\t\t\t\t\t} else if (this.selectedAlgorithm.type != 'unweighted' && (!this.intersectedNode || !ends.includes(this.intersectedNode.status))) {\n\t\t\t\t\t\tthis.grid[coords.row][coords.col].status =\n\t\t\t\t\t\t\tthis.grid[coords.row][coords.col].status == \"wall\" ? \"default\" : \"wall\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.intersectedNode = this.grid[coords.row][coords.col];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tanimatePlayer(delta) {\n\t\t\tlet playerSpeed = 300;\n\t\t\t// Gradual slowdown\n\t\t\tthis.pointerLock.velocity.x -= this.pointerLock.velocity.x * 10.0 * delta;\n\t\t\tthis.pointerLock.velocity.z -= this.pointerLock.velocity.z * 10.0 * delta;\n\n\t\t\tif (this.detectPlayerCollision() == false) {\n\t\t\t\tthis.pointerLock.direction.z =\n\t\t\t\t\tNumber(this.pointerLock.moveForward) - Number(this.pointerLock.moveBackward);\n\t\t\t\tthis.pointerLock.direction.x =\n\t\t\t\t\tNumber(this.pointerLock.moveRight) - Number(this.pointerLock.moveLeft);\n\t\t\t\tthis.pointerLock.direction.normalize(); // this ensures consistent movements in all directions\n\t\n\t\t\t\tif (this.pointerLock.moveForward || this.pointerLock.moveBackward)\n\t\t\t\t\tthis.pointerLock.velocity.z -= this.pointerLock.direction.z * playerSpeed * delta;\n\t\t\t\tif (this.pointerLock.moveLeft || this.pointerLock.moveRight)\n\t\t\t\t\tthis.pointerLock.velocity.x -= this.pointerLock.direction.x * playerSpeed * delta;\n\t\n\t\t\t\tthis.controls.moveRight(-this.pointerLock.velocity.x * delta);\n\t\t\t\tthis.controls.moveForward(-this.pointerLock.velocity.z * delta);\n\t\t\t} else {\n\t\t\t\tthis.pointerLock.velocity.x = 0;\n\t\t\t\tthis.pointerLock.velocity.z = 0;\n\t\t\t}\n\n\t\t\tthis.pointerLock.velocity.y -= 9.8 * 50.0 * delta; // 50.0 = mass\n\t\t\tif(this.detectOnObject()) {\n\t\t\t\tthis.pointerLock.velocity.y = Math.max(0, this.pointerLock.velocity.y);\n\t\t\t\tthis.pointerLock.canJump = true;\n\t\t\t}\n\t\t\tthis.controls.getObject().position.y += this.pointerLock.velocity.y * delta;\n\n\t\t\tif (this.controls.getObject().position.y < this.cameraY) {\n\t\t\t\tthis.pointerLock.velocity.y = 0;\n\t\t\t\tthis.controls.getObject().position.y = this.cameraY;\n\t\t\t\tthis.pointerLock.canJump = true;\n\t\t\t}\n\t\t},\n\n\t\tdetectPlayerCollision() {\n\t\t\tlet rotationMatrix;\n\t\t\t// Get direction of camera\n\t\t\tlet cameraDirection = this.controls.getDirection(new THREE.Vector3(0, 0, 0)).clone();\n\t\t\tlet collisionDistance = 1;\n\n\t\t\t// Check which direction we're moving (not looking)\n\t\t\t// Flip matrix to that direction so that we can reposition the ray\n\t\t\tif (this.pointerLock.moveBackward) {\n\t\t\t\trotationMatrix = new THREE.Matrix4();\n\t\t\t\trotationMatrix.makeRotationY(this.degreesToRadians(180));\n\t\t\t} else if (this.pointerLock.moveLeft) {\n\t\t\t\trotationMatrix = new THREE.Matrix4();\n\t\t\t\trotationMatrix.makeRotationY(this.degreesToRadians(90));\n\t\t\t} else if (this.pointerLock.moveRight) {\n\t\t\t\trotationMatrix = new THREE.Matrix4();\n\t\t\t\trotationMatrix.makeRotationY(this.degreesToRadians(270));\n\t\t\t}\n\n\t\t\t// Player is not moving forward, apply rotation matrix needed\n\t\t\tif (rotationMatrix !== undefined) {\n\t\t\t\tcameraDirection.applyMatrix4(rotationMatrix);\n\t\t\t}\n\n\t\t\t// Apply ray to player camera\n\t\t\tlet rayCaster = new THREE.Raycaster(this.controls.getObject().position, cameraDirection);\n\n\t\t\t// If our ray hit a collidable object, return true\n\t\t\tif (this.rayIntersect(rayCaster, collisionDistance)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tdetectOnObject() {\n\t\t\tlet collisionDistance = this.cameraY+1;\n\t\t\tlet rayCaster = new THREE.Raycaster(this.controls.getObject().position, new THREE.Vector3(0, -1, 0));\n\t\t\t// rayCaster.ray.origin.y -= this.cameraY;\n\t\t\tif (this.rayIntersect(rayCaster, collisionDistance)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tdeviceCamLoop() {\n\t\t\tlet videoCtx = this.videoCanvas.getContext(\"2d\");\n\n\t\t\tvideoCtx.drawImage(this.video, 0, 0, this.videoCanvas.width, this.videoCanvas.height);\n\t\t\tlet pixels = videoCtx.getImageData(0, 0, this.videoCanvas.width, this.videoCanvas.height);\n\t\t\tfor(let y=0; y<this.videoCanvas.height; y++) {\n\t\t\t\tfor(let x=0; x<this.videoCanvas.width; x++) {\n\t\t\t\t\tlet index = (x + y * this.videoCanvas.width) * 4;\n\t\t\t\t\tlet r = pixels.data[index+0];\n\t\t\t\t\tlet g = pixels.data[index+1];\n\t\t\t\t\tlet b = pixels.data[index+2];\n\t\t\t\t\t\n\t\t\t\t\tlet brightness = Math.floor((r+g+b)/3);\n\t\t\t\t\tlet gridX = Math.floor(this.videoCanvas.width-1-x);\n\t\t\t\t\tlet status = \"default\";\n\t\t\t\t\tif (y == this.start.row && gridX == this.start.col) {\n\t\t\t\t\t\tstatus = \"start\";\n\t\t\t\t\t} else if (y == this.finish.row && gridX == this.finish.col) {\n\t\t\t\t\t\tstatus = \"finish\";\n\t\t\t\t\t}\n\t\t\t\t\tif(brightness > this.thresholdValue) {\n\t\t\t\t\t\tthis.grid[y][gridX].status = status;\n\t\t\t\t\t} else if(status != 'start' && status != 'finish') {\n\t\t\t\t\t\tthis.grid[y][gridX].status = 'wall';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trayIntersect(ray, distance) {\n\t\t\tvar intersects = ray.intersectObjects(this.collidableObjects);\n\t\t\tfor (var i = 0; i < intersects.length; i++) {\n\t\t\t\t// Check if there's a collision\n\t\t\t\tif (intersects[i].distance < distance) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\taddControls() {\n\t\t\tthis.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);\n\t\t\tthis.pointerLockControls = new PointerLockControls(this.camera, this.renderer.domElement);\n\t\t\tthis.pointerLockControls.addEventListener(\"lock\", function() {\n\t\t\t\tconsole.log(\"Pointer Locked\");\n\t\t\t});\n\t\t\tthis.pointerLockControls.addEventListener(\"unlock\", function() {\n\t\t\t\tconsole.log(\"Pointer Unlocked\");\n\t\t\t});\n\t\t\t// Clock\n\t\t\tthis.clock = new THREE.Clock();\n\t\t\tdocument.addEventListener(\"keydown\", this.onKeyDown, false);\n\t\t\tdocument.addEventListener(\"keyup\", this.onKeyUp, false);\n\t\t\tthis.pointerLock.velocity = new THREE.Vector3();\n\t\t\tthis.pointerLock.direction = new THREE.Vector3();\n\t\t\tthis.scene.add(this.pointerLockControls.getObject());\n\t\t},\n\n\t\tsetControls(fromInit = false) {\n\t\t\tlet vm = this;\n\t\t\tTWEEN.removeAll();\n\t\t\tif (this.controlType == \"Orbit\") {\n\t\t\t\t// OrbitControls\n\t\t\t\tthis.cameraY = this.defaultCameraY;\n\t\t\t\tthis.camera.near = 1;\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\t\tthis.controls = this.orbitControls;\n\t\t\t\tthis.controls.enabled = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvm.resetCamera();\n\t\t\t\t}, fromInit ? 800 : 0);\n\t\t\t} else if (this.controlType == \"PointerLock\") {\n\t\t\t\t// PointerLock controls\n\t\t\t\tthis.cameraY = 3;\n\t\t\t\tthis.camera.near = 0.05;\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\t\tthis.controls.enabled = false;\n\t\t\t\tthis.controls = this.pointerLockControls;\n\t\t\t\tlet startPosition = this.ground.geometry.vertices[\n\t\t\t\t\tthis.grid[this.start.row][this.start.col].faces[1][\"a\"]\n\t\t\t\t];\n\t\t\t\tnew TWEEN.Tween(this.camera.position)\n\t\t\t\t\t.to(startPosition, 2000)\n\t\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t\t.start();\n\t\t\t\tnew TWEEN.Tween(this.camera.rotation)\n\t\t\t\t\t.to({ x: 0, y: (5 * Math.PI) / 4, z: 0 }, 2000)\n\t\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t\t.start();\n\t\t\t}\n\t\t},\n\n\t\tresetCamera() {\n\t\t\tnew TWEEN.Tween(this.camera.position)\n\t\t\t\t.to({ x: 0, y: this.cameraY, z: 0 }, 2000)\n\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t.onUpdate(() => {\n\t\t\t\t\tthis.camera.lookAt(this.scene.position);\n\t\t\t\t})\n\t\t\t\t.onComplete(() => {\n\t\t\t\t\tlet lookDirection = new THREE.Vector3();\n\t\t\t\t\tthis.camera.getWorldDirection(lookDirection);\n\t\t\t\t\tthis.controls.target\n\t\t\t\t\t\t.copy(this.camera.position)\n\t\t\t\t\t\t.add(lookDirection.multiplyScalar(this.cameraY));\n\t\t\t\t})\n\t\t\t\t.start();\n\t\t\tnew TWEEN.Tween(this.camera.rotation)\n\t\t\t\t.to({ x: -Math.PI / 2, y: 0, z: 0 }, 2000)\n\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t.start();\n\t\t},\n\n\t\tresizeHandler(event) {\n\t\t\tlet width = window.innerWidth,\n\t\t\t\theight = window.innerHeight;\n\t\t\tthis.renderer.setSize(width, height);\n\t\t\tthis.camera.aspect = width / height;\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t},\n\n\t\tinitGrid() {\n\t\t\tlet vm = this;\n\t\t\tfor (let i = 0; i < this.rows; i++) {\n\t\t\t\tlet currentRow = [];\n\t\t\t\tfor (let j = 0; j < this.cols; j++) {\n\t\t\t\t\tlet node = this.createNode(i, j);\n\t\t\t\t\tcurrentRow.push(node);\n\t\t\t\t}\n\t\t\t\tthis.grid.push(currentRow);\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.rows; i++) {\n\t\t\t\tfor (let j = 0; j < this.cols; j++) {\n\t\t\t\t\tthis.$watch(\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\treturn this.grid[i][j];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tthis.nodeWatcher,\n\t\t\t\t\t\t{ deep: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tcreateNode(row, col) {\n\t\t\tlet faces = {};\n\t\t\tlet faceIndex = row * 2 * this.cols + col * 2;\n\t\t\tfaces[1] = this.ground.geometry.faces[faceIndex];\n\t\t\tfaceIndex = faceIndex % 2 == 0 ? faceIndex + 1 : faceIndex - 1;\n\t\t\tfaces[2] = this.ground.geometry.faces[faceIndex];\n\n\t\t\tlet status = \"default\";\n\t\t\tif (row == this.start.row && col == this.start.col) {\n\t\t\t\tstatus = \"start\";\n\t\t\t} else if (row == this.finish.row && col == this.finish.col) {\n\t\t\t\tstatus = \"finish\";\n\t\t\t}\n\n\t\t\t// Node info\n\t\t\tlet node = {\n\t\t\t\tid: row * this.cols + col,\n\t\t\t\trow: row,\n\t\t\t\tcol: col,\n\t\t\t\tfaces: faces,\n\t\t\t\tstatus: status,\n\t\t\t\tdistance: Infinity,\n\t\t\t\ttotalDistance: Infinity,\n\t\t\t\theuristicDistance: null,\n\t\t\t\tdirection: null,\n\t\t\t\tweight: 0,\n\t\t\t\tpreviousNode: null,\n\t\t\t};\n\n\t\t\tif (status == \"start\") {\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.start]);\n\t\t\t} else if (status == \"finish\") {\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.finish]);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t},\n\n\t\tnodeWatcher(newVal, oldVal) {\n\t\t\t// console.log('WATCHER', newVal);\n\t\t\tif (this.visualizerState == \"running\") return;\n\t\t\tthis.updateNode(newVal, this.streaming);\n\t\t},\n\n\t\tupdateNode(node, instant = false) {\n\t\t\tif (node.status == \"wall\") {\n\t\t\t\tlet scaleY = 0.5 + Math.random();\n\t\t\t\tif(!instant) {\n\t\t\t\t\tthis.addWall(node, scaleY, instant ? 0 : 1000);\n\t\t\t\t}\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.wall]);\n\t\t\t} else if (node.status == \"start\") {\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.start]);\n\t\t\t} else if (node.status == \"finish\") {\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.finish]);\n\t\t\t} else if (node.status == \"visited\") {\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.visited]);\n\t\t\t} else {\n\t\t\t\tif (this.walls[node.id] != null && this.walls[node.id].visible && !instant) {\n\t\t\t\t\tthis.hideWall(this.walls[node.id]);\n\t\t\t\t}\n\t\t\t\ttweenToColor(node, this.ground.geometry, [this.colors.default]);\n\t\t\t}\n\t\t},\n\n\t\taddWall(node, scaleY, duration) {\n\t\t\tif (!!this.walls[node.id]) {\n\t\t\t\tif(!this.walls[node.id].visible) {\n\t\t\t\t\tthis.showWall(this.walls[node.id], scaleY, duration);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet materialId = 1 + Math.floor(Math.random() * (this.wallMaterials.length - 1));\n\t\t\tlet wall = new THREE.Mesh(this.wallGeomtery, this.wallMaterials[materialId]);\n\t\t\twall.name = \"wall\";\n\t\t\twall.wallId = node.id;\n\t\t\twall.scale.y = scaleY;\n\t\t\twall.castShadow = true;\n\t\t\twall.receiveShadow = true;\n\t\t\tthis.scene.add(wall);\n\t\t\tthis.$set(this.walls, node.id, wall);\n\n\t\t\tlet gridWidth = this.cols * this.nodeDimensions.width;\n\t\t\tlet gridHeight = this.rows * this.nodeDimensions.height;\n\t\t\tlet height = this.wallGeomtery.parameters.height * wall.scale.y;\n\t\t\tlet x = -gridWidth / 2 + this.nodeDimensions.width / 2 + node.col * this.nodeDimensions.width,\n\t\t\t\ty = height / 2,\n\t\t\t\tz =\n\t\t\t\t\t-gridHeight / 2 + this.nodeDimensions.height / 2 + node.row * this.nodeDimensions.height;\n\t\t\t\n\t\t\tif(duration == 0) {\n\t\t\t\twall.position.set(x, y, z);\n\t\t\t} else {\n\t\t\t\twall.position.set(x, height, z);\n\t\t\t\tnew TWEEN.Tween(wall.position)\n\t\t\t\t\t.to({ x: x, y: y, z: z }, duration)\n\t\t\t\t\t.easing(TWEEN.Easing.Bounce.Out)\n\t\t\t\t\t.start();\n\t\t\t}\n\t\t},\n\n\t\tshowWall(wall, scaleY, duration) {\n\t\t\twall.scale.y = scaleY;\n\t\t\tlet height = wall.geometry.parameters.height * wall.scale.y;\n\t\t\twall.visible = true;\n\t\t\tif(duration == 0) {\n\t\t\t\twall.position.setY(height/2);\n\t\t\t} else {\n\t\t\t\twall.position.setY(height);\n\t\t\t\tnew TWEEN.Tween(wall.position)\n\t\t\t\t\t.to({ y: height / 2 }, duration)\n\t\t\t\t\t.easing(TWEEN.Easing.Bounce.Out)\n\t\t\t\t\t.start();\n\t\t\t}\n\t\t},\n\n\t\thideWall(wall) {\n\t\t\twall.visible = false;\n\t\t},\n\n\t\tonMouseDown(event) {\n\t\t\tthis.down = true;\n\t\t\tthis.moved = false;\n\t\t\tthis.currentEvent = event;\n\t\t\tthis.setMouseVector(event, \"move\");\n\t\t\tthis.clearFocus();\n\t\t},\n\t\tonMouseMove(event) {\n\t\t\tif (!this.down) return;\n\t\t\tthis.moved = true;\n\t\t\tif (this.worldSetup) {\n\t\t\t\tthis.setMouseVector(event, \"move\");\n\t\t\t}\n\t\t},\n\t\tonMouseLeave() {\n\t\t\tif (this.moved) {\n\t\t\t\tthis.onMouseup();\n\t\t\t}\n\t\t\tthis.down = false;\n\t\t},\n\t\tonMouseup(event) {\n\t\t\tlet threshold = 25;\n\t\t\tif (this.moved) {\n\t\t\t\tlet dist = 0;\n\t\t\t\tif (this.currentEvent.touches && this.currentEvent.touches.length > 0) {\n\t\t\t\t\tdist = this.calcDist(\n\t\t\t\t\t\tthis.currentEvent.touches[0].pageX - event.changedTouches[0].pageX,\n\t\t\t\t\t\tthis.currentEvent.touches[0].pageY - event.changedTouches[0].pageY\n\t\t\t\t\t);\n\t\t\t\t\tdist > threshold ? this.moveHandler(event) : this.clickHandler(event);\n\t\t\t\t} else {\n\t\t\t\t\tthis.moveHandler(event);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.clickHandler(event);\n\t\t\t}\n\t\t\tthis.currentEvent = null;\n\t\t\tthis.moved = false;\n\t\t\tthis.down = false;\n\t\t},\n\n\t\tcalcDist(x, y) {\n\t\t\treturn x * x + y * y;\n\t\t},\n\n\t\tsetMouseVector(event, type) {\n\t\t\tlet touchEvent = type == \"click\" ? this.currentEvent : event;\n\t\t\tif (touchEvent.touches && touchEvent.touches.length > 0) {\n\t\t\t\tthis.mouse.x = (touchEvent.touches[0].clientX / window.innerWidth) * 2 - 1;\n\t\t\t\tthis.mouse.y = -(touchEvent.touches[0].clientY / window.innerHeight) * 2 + 1;\n\t\t\t} else {\n\t\t\t\tthis.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n\t\t\t\tthis.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\t\t\t}\n\t\t},\n\n\t\tmoveHandler(event) {\n\t\t\t// console.log(\"Moved\");\n\t\t},\n\n\t\tclickHandler(event) {\n\t\t\tif (this.worldSetup || this.controlType == \"PointerLock\") return;\n\t\t\tthis.setMouseVector(event, \"click\");\n\t\t\tthis.raycaster.setFromCamera(this.mouse, this.camera);\n\t\t\tlet intersects = this.raycaster.intersectObjects(this.clickableObjects); //array\n\t\t\tif (intersects.length > 0) {\n\t\t\t\tlet coords;\n\t\t\t\tif (intersects[0].object.name == \"wall\") {\n\t\t\t\t\tcoords = this.faceIndexToCoordinates(intersects[0].object.wallId * 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar faceIndex = intersects[0].faceIndex;\n\t\t\t\t\tconsole.log(faceIndex);\n\t\t\t\t\tcoords = this.faceIndexToCoordinates(faceIndex);\n\t\t\t\t}\n\t\t\t\tthis.$emit(\"clickEvent\", this.grid[coords.row][coords.col]);\n\t\t\t}\n\t\t},\n\n\t\tdegreesToRadians(degrees) {\n\t\t\treturn degrees * Math.PI/180;\n\t\t},\n\n\t\tfaceIndexToCoordinates(faceIndex) {\n\t\t\t// As each node has 2 faces\n\t\t\treturn {\n\t\t\t\trow: Math.floor(faceIndex / 2 / this.rows),\n\t\t\t\tcol: Math.floor((faceIndex / 2) % this.cols),\n\t\t\t};\n\t\t},\n\n\t\tclearFocus() {\n\t\t\tdocument.getElementsByClassName(\"header\")[0].click();\n\t\t},\n\n\t\tonKeyDown(event) {\n\t\t\tif (this.controlType == \"Orbit\") {\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\t// case 72:  // h\n\t\t\t\t\t// \tthis.hemisphereLight.visible = !this.hemisphereLight.visible;\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\t// case 68: // d\n\t\t\t\t\t// \tthis.directionalLight.visible = !this.directionalLight.visible;\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 87: // w\n\t\t\t\t\t\tthis.$emit('switchWorldSetup');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 80: // p\n\t\t\t\t\t\tthis.$emit('switchControlType');\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\tcase 38: // up\n\t\t\t\t\tcase 87: // w\n\t\t\t\t\t\tthis.pointerLock.moveForward = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37: // left\n\t\t\t\t\tcase 65: // a\n\t\t\t\t\t\tthis.pointerLock.moveLeft = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40: // down\n\t\t\t\t\tcase 83: // s\n\t\t\t\t\t\tthis.pointerLock.moveBackward = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39: // right\n\t\t\t\t\tcase 68: // d\n\t\t\t\t\t\tthis.pointerLock.moveRight = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32: // space\n\t\t\t\t\t\tif (this.pointerLock.canJump === true) this.pointerLock.velocity.y += 200;\n\t\t\t\t\t\tthis.pointerLock.canJump = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 80: // P\n\t\t\t\t\t\tif(!this.controls.isLocked) {\n\t\t\t\t\t\t\tthis.$emit('switchControlType');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tonKeyUp(event) {\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase 38: // up\n\t\t\t\tcase 87: // w\n\t\t\t\t\tthis.pointerLock.moveForward = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 37: // left\n\t\t\t\tcase 65: // a\n\t\t\t\t\tthis.pointerLock.moveLeft = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: // down\n\t\t\t\tcase 83: // s\n\t\t\t\t\tthis.pointerLock.moveBackward = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39: // right\n\t\t\t\tcase 68: // d\n\t\t\t\t\tthis.pointerLock.moveRight = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t},\n};\n</script>\n\n<style lang=\"scss\">\n#visualizer {\n\theight: 100vh;\n\twidth: 100vw;\n}\n</style>\n"]}]}